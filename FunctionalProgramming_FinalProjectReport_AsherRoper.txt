Functional Programming Final Project ReportAsher Roper      For my final project, I decided to program a Sudoku solver. At the beginning, I didn’t know how to approach the solver, but immediately found online sources indicating the backtracking method works best.      The backtracker is complicated to implement, but straightforward in practice. For it to work, there first needs to be a list of all possible values for each empty cell in the puzzle.  Starting from the top left and going down each row, the solver fills each square with the first possible value in the possible values list, and updates the possibilities of each empty cell, as values are set.	As the solver repeats this process, there will (unless insanely lucky) be a case where every possibility for some empty cell is eliminated. At this stage, the solver backtracks to the empty cell it filled last and replaces its value with the next legal value in the possible values list. This is done repeatedly until the entire puzzle is solved, or all possibilities are eliminated, indicating the puzzle is unsolvable.	That being said, I was not actually able to successfully program the backtracker for my project. I was able to program all the other necessary components of my project such as building lists of rows, columns, blocks, blank coordinates, possible values per blank coordinate, checking legal values against the puzzle, updating the puzzle with values, etc.	I had an extremely difficult time programming even the components I was able to implemented just because of my lack of familiarity with Haskell. However, once figuring out my issues with the language and finding the right function to use in each situation, I found that Haskell was a great language to program this solver. I found that many of the default Haskell functions were able to do the heavy lifting for me.	For example, to get a list of columns in my Sudoku puzzle (which is initialized as a list of lists where every inner list represents a row of the puzzle from the top down) I spent a lot of time messing around with list comprehensions. I was actually getting close to obtaining a list of columns, but then I found that the function, “transpose” did this for me just by calling it on my puzzle.	I also had a lot of trouble making a list of blocks for my puzzle. I initially tried to build the list of blocks in the natural order of the puzzle (top left to bottom right), but had a tough time with this. I found that by combining the use of the transpose function with what I was already doing made it so I didn’t obtain a list of blocks in the order I preferred, but was able to obtain every block in the puzzle in a straightforward manner. I was able to fix the order of the blocks by writing a messier function called, “getBlocks”.	My function, “blankCoordinates” was another one that I over complicated. I kept on trying to write this function in Haskell like I would in Java or C, which I’ve learned through the course of this class/project that is always a mistake.  I wrote a ton of conditionals and index checks for cells with the value 0 (which is how I chose to indicate a blank cell) which became messy fast. I later realized a simple list comprehension would again do all the heavy lifting for me.	When it finally came to my solve function, I was not able to implement it properly, but I’ll try and explain the intent behind it. My solve function takes a puzzle, and a list of possibilities. A possibility in my program is a list of coordinates associated to a list of possible cell values. The list of coordinates in the case of the solver is of course the list of empty cells and the associated list of values are the values possible for each empty cell. 	The solver has an if statement that calls the function checkUpdatedBoard. This function checks if the current (starting from the first empty cell from coordinate (0,0)) empty cell can take the first value from the possible values list associated to it is legal. If checkUpdatedBoard returns true, solve is called recursively passing that updated version of the board along with the rest of possibilities list as xs. If checkUpdatedBoard returns false, it calls solve recursively with the current state of the board, but with the head of the possibility list associated to the current empty cell removed. This was also intended to backtrack to the previously filled empty cell and remove the head of the possibility list associated to that cell, so it can check its next value on it.	If you look at my main function that’s commented out, you can see how I intended to solve the Sudoku puzzle. I tried passing the solver the hard coded (and solvable) Sudoku puzzle along with a possibilities list.	If I had more time to solve this, I would’ve redesigned my program to work a bit differently. I spent a lot of time struggling creating the possibilities list. However I found from sources online a better method to implement this. I could have made it so that my puzzle had that possibility list built into it for each empty cell. By separating the two, I made my process a lot more complex. This complexion was what probably made my solver to difficult to deal with. Simpler components would have made for a simpler solver. 